<!DOCYTPE html>
<html>
  <head>
    <script src="js/jquery-1.8.3.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src='js/THREEx.KeyboardState.js'></script>
    
    <script src='city.js'></script>
    <script src='vehicles.js'></script>
    
    <style type-"text/css">
body {
  margin: 0;
  padding: 0;
  background-color: #000000;
}
    </style>
  </head>
  <body>
    <script type="text/javascript">

var camera, scene, renderer;
var geometry, material, mesh;
var keyboard;
var camera_target = new THREE.Vector3( 0, 0, 0 );

var camera, scene, renderer,
isMouseDown = false, onMouseDownPosition,
radius = 1600, theta = 45, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60;

var heli;
var autoheli = true;

init();
animate();

function init() {

  camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
  camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
  camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
  camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
  camera.lookAt(camera_target);
  //camera.target.position.y = 0;

  scene = new THREE.Scene();
  
  City.init(5, 5);
  
  /* Ground */
  
  
  for(var x=0; x<City.width_blocks; x++) {
    for(var z=0;z<City.depth_blocks; z++) {
      
      var building = City.buildings[x][z];
      
      /* Building */
      /*geometry = new THREE.CubeGeometry(building.width, building.height, building.depth);
      material = new THREE.MeshBasicMaterial( { color: building.colour, wireframe: false } );
      mesh = new THREE.Mesh( geometry, material );*/

			var blockoffset = City.blockOffsetByIndex(x, z);
			
      mesh = building.getMesh();
      
      mesh.translateX(blockoffset.x - (City.width/2));
      mesh.translateZ(blockoffset.z - (City.depth/2));
			mesh.receiveShadow = true;
      scene.add( mesh );
      
      /* Ground */
      ground_texture = building.getConcreteTexture(City.block.width, City.block.depth, 0x808080);
      ground_mesh = new THREE.Mesh(
                            new THREE.CubeGeometry(City.block.width, 2, City.block.depth),
                            new THREE.MeshPhongMaterial( { color: 0x808080, wireframe: false, map:ground_texture } )
                           );
      ground_mesh.translateX(blockoffset.x - (City.width/2));
      ground_mesh.translateZ(blockoffset.z - (City.depth/2));
      ground_mesh.translateY(0);
			ground_mesh.receiveShadow = true;
      scene.add( ground_mesh );
      
      /* Roads */
      if(x < City.width_blocks-1) {
        mesh = new THREE.Mesh(
                              new THREE.CubeGeometry(City.road_width, 1, City.block.width+(City.road_width*2)),
                              new THREE.MeshPhongMaterial( { color: 0x303030, wireframe: false } )
                             );
        mesh.translateX(blockoffset.x + City.block.width - City.road_width - (City.road_width/2) - (City.width/2));
        mesh.translateZ(blockoffset.z - (City.depth/2));
        mesh.translateY(-1);
				mesh.receiveShadow = true;
        scene.add( mesh );
      }
      if(z < City.depth_blocks-1) {
        mesh = new THREE.Mesh(
                              new THREE.CubeGeometry(City.block.depth+(City.road_width*2), 1, City.road_width),
                              new THREE.MeshPhongMaterial( { color: 0x303030, wireframe: false } )
                             );
        mesh.translateX(blockoffset.x - (City.width/2));
        mesh.translateZ(blockoffset.z + City.block.depth - City.road_width - (City.road_width/2) - (City.depth/2));
        mesh.translateY(-1);
				mesh.receiveShadow = true;
        scene.add( mesh );
      }
      
      /* Streetlights */
			
			var streetlights = [];
			
      if(z != 0 || x != 0) {
        streetlights.push([blockoffset.x - (City.block.width/2) - (City.width/2), 10, blockoffset.z - (City.block.depth/2) - (City.depth/2)]);
      }
      if(z != 0) {
				streetlights.push([blockoffset.x - (City.width/2), 10, blockoffset.z - (City.block.depth/2) - (City.depth/2)]);
      }
      if(z != 0 || x != City.width_blocks-1) {
				streetlights.push([blockoffset.x + (City.block.width/2) - (City.width/2), 10, blockoffset.z - (City.block.depth/2) - (City.depth/2)]);
      }
      
      if(x != 0) {
				streetlights.push([blockoffset.x - (City.block.width/2) - (City.width/2), 10, blockoffset.z - (City.depth/2)]);
      }
      if(x != City.width_blocks-1) {
				streetlights.push([blockoffset.x + (City.block.width/2) - (City.width/2), 10, blockoffset.z - (City.depth/2)]);
      }
        
      if(z != City.depth_blocks-1 || x != 0) {
				streetlights.push([blockoffset.x - (City.block.width/2) - (City.width/2), 10, blockoffset.z + (City.block.depth/2) - (City.depth/2)]);
      }
      if(z != City.depth_blocks-1) {
				streetlights.push([blockoffset.x - (City.width/2), 10, blockoffset.z + (City.block.depth/2) - (City.depth/2)]);
      }
      if(z != City.depth_blocks-1 || x != City.width_blocks-1) {
				streetlights.push([blockoffset.x + (City.block.width/2) - (City.width/2), 10, blockoffset.z + (City.block.depth/2) - (City.depth/2)]);
      }
			
			for(var i=0; i<streetlights.length; i++) {
				placeholder = new THREE.Mesh(new THREE.CubeGeometry(2, 2, 2), new THREE.MeshBasicMaterial( { color: 0xffd000, wireframe: false }));
        placeholder.translateX(streetlights[i][0]);
        placeholder.translateY(streetlights[i][1]);
        placeholder.translateZ(streetlights[i][2]);
        scene.add(placeholder);
			}
			
			if(x > 0 && z > 0) {
				var fake_streetlamp = new THREE.PointLight( 0xffd000, 1, 60);
				fake_streetlamp.position.set(blockoffset.x - (City.block.width/2) - (City.road_width/2) - (City.width/2), 5, blockoffset.z - (City.block.depth/2) - (City.road_width/2) - (City.depth/2));
        /*streetlamp.castShadow = true;
				streetlamp.shadowDarkness = 0.5;
				streetlamp.shadowCameraVisible = true;*/
				
        scene.add(fake_streetlamp);
				
				/*placeholder = new THREE.Mesh(new THREE.CubeGeometry(2, 2, 2), new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: false }));
        placeholder.translateX(blockoffset.x - (City.block.width/2) - (City.road_width/2) - (City.width/2));
        placeholder.translateY(10);
        placeholder.translateZ(blockoffset.z - (City.block.depth/2) - (City.road_width/2) - (City.depth/2));
        scene.add(placeholder);*/

			}
			

    }
  }
  
  // Lights

  var ambient = new THREE.AmbientLight( 0x202020 );
  scene.add( ambient );

  /*directionalLight = new THREE.DirectionalLight( 0xc0c0c0 );
  directionalLight.position.set( 100, 50, 10 ).normalize();
  //directionalLight.castShadow = true;
  scene.add( directionalLight );*/

				
  
  //renderer = new THREE.CanvasRenderer();
  renderer = new THREE.WebGLRenderer({
    antialias		: true,	// to get smoother output
  });
	renderer.shadowMapSoft		= true;
  renderer.setSize( window.innerWidth, window.innerHeight );
  
  onMouseDownPosition = new THREE.Vector2();
  
  document.body.appendChild( renderer.domElement );
  
  document.addEventListener( 'mousemove', onDocumentMouseMove, false );
  document.addEventListener( 'mousedown', onDocumentMouseDown, false );
  document.addEventListener( 'mouseup', onDocumentMouseUp, false ); 

  document.addEventListener( 'mousewheel', onDocumentMouseWheel, false ); 
  document.addEventListener( 'wheel', onDocumentMouseWheel, false ); 

  keyboard = new THREEx.KeyboardState();
  
  heli = new Helicopter(scene);
}

function animate() {
  // note: three.js includes requestAnimationFrame shim
  requestAnimationFrame( animate );
  if(autoheli) {
    heli.step();
  }
  renderer.render( scene, camera );
}

setInterval(function() {
  if(keyboard.pressed("right")) {
    autoheli = true;
  }
  if(keyboard.pressed("left")) {
    autoheli = false;
  }
  if(keyboard.pressed("up")) {
    heli.step();
  }
  renderer.render( scene, camera );
}, 100);

function onDocumentMouseDown( event ) {
  event.preventDefault();
  isMouseDown = true;
  onMouseDownTheta = theta;
  onMouseDownPhi = phi;
  onMouseDownPosition.x = event.clientX;
  onMouseDownPosition.y = event.clientY;
}

function onDocumentMouseMove( event ) {
  event.preventDefault();
  if ( isMouseDown ) {
    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;
    phi = Math.min( 180, Math.max( 0, phi ) );
    camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
    camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
    camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
    camera.lookAt(camera_target);
    camera.updateMatrix();
  }
  renderer.render( scene, camera );
}

function onDocumentMouseUp( event ) {
  event.preventDefault();
  isMouseDown = false;
  onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
  onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;
  if ( onMouseDownPosition.length() > 5 ) {
    return;
  }
  renderer.render( scene, camera );
}

function onDocumentMouseWheel(event) {
  event.preventDefault();

  if(event.deltaY) {
    radius += event.deltaY*10;
  }
  else {
    radius -= event.wheelDeltaY;
  }
  camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
  camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
  camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
  camera.lookAt(camera_target);
  camera.updateMatrix();
  renderer.render( scene, camera );
}



    </script>
  </body>
</html>
